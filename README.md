# Зоопарк ERP-система

Это приложение представляет собой систему управления зоопарком, которая включает в себя управление животными, добавление новых животных и контроль их здоровья. Все животные могут быть классифицированы на травоядных и хищников, и система поддерживает добавление вещей в инвентарь зоопарка.


Небольшое отсупление:  у меня в классе animal также есть интрейфес Inventory, я этот интерфейс реализовал,как хранение порядкового номмера животного/вещи(по скольку друого не было оговорено и сделал на свое усмотрение) аналог ID. Не совсем понимаю смысла тк там либо хранить колличество вещей либо их номер, просто колличество вещей и так легко вычислить через сортирову листа условно, а id куда более полезен.

## Как клонировать и запустить

1. Клонируйте репозиторий на свой локальный компьютер:

    ```bash
    git clone https://github.com/karablik27/ZooERPSystem_HW1.git
    ```

2. Откройте проект в **Visual Studio** или в другом C#-совместимом IDE.

3. Скомпилируйте и запустите проект через IDE или используйте команду:

    ```bash
    dotnet run
    ```

4. Следуйте инструкциям в консоли, чтобы добавлять животных, вещи и управлять зоопарком.

## Основные принципы SOLID, применяемые в проекте

### 1. **Принцип единственной ответственности (Single Responsibility Principle)**

Каждый класс в проекте выполняет одну задачу. Например:
- Класс `Herbo` отвечает только за данные травоядных животных.
- Класс `Predator` отвечает только за данные хищных животных.
- Класс `Zoo` управляет коллекциями животных и вещами.

### 2. **Принцип открытости/закрытости (Open/Closed Principle)**

Классы и методы открыты для расширения, но закрыты для изменений. Например:
- Классы животных (`Herbo` и `Predator`) могут быть расширены для добавления новых типов животных, не изменяя существующий код.
- Мы можем добавлять новые типы животных, создавая новые классы, такие как `Monkey` или `Rabbit`, без изменения базовых классов `Herbo` или `Predator`.

### 3. **Принцип подстановки Лисков (Liskov Substitution Principle)**

Объекты производных классов могут быть заменены объектами базовых классов без нарушения корректности программы. Например:
- Мы можем использовать любой объект, который наследуется от `Herbo` или `Predator` в коллекции зоопарка, и система будет работать корректно.

### 4. **Принцип разделения интерфейса (Interface Segregation Principle)**

Мы разделили интерфейсы и классы на несколько меньших и специфичных. Например:
- Интерфейсы, такие как `IInventory`, используются для представления вещей в зоопарке, а классы животных не зависят от интерфейсов, которые им не нужны.

### 5. **Принцип инверсии зависимостей (Dependency Inversion Principle)**

Мы инвертируем зависимости в проекте, например:
- Класс `Zoo` зависит от абстракции `IHealthChecker`, а не от конкретного класса, такого как `VeterinaryClinic`. Это позволяет нам подменить реализацию проверки здоровья животных, не меняя код класса зоопарка.

## Класс `Zoo` и ассоциация с классом ветеринарной клиники

Класс `Zoo` управляет животными и инвентарем. Он имеет ассоциацию с классом `VeterinaryClinic`, который проверяет здоровье новых животных перед их добавлением в коллекцию зоопарка. Класс `Zoo` использует интерфейс `IHealthChecker` для связи с классами, которые проверяют здоровье животных.

В этом проекте используется **Dependency Injection (DI) контейнер** для управления зависимостями между объектами. DI помогает легко подменять реализации различных компонентов и упрощает тестирование и поддержку приложения.

### Как работает DI в нашем проекте:

1. **Регистрация сервисов**:
   В методе `Main` мы создаем контейнер зависимостей с помощью библиотеки `Microsoft.Extensions.DependencyInjection`. Мы регистрируем все необходимые компоненты (сервисы) в контейнере:
   
   - **`IHealthChecker`** (интерфейс проверки здоровья животных) реализуется через класс **`VeterinaryClinic`**. Мы регистрируем его как **singleton**, чтобы использовать единственный экземпляр этого класса во всей программе.
   
   - **`Zoo`** и **`ConsoleInterface`** также регистрируются как **singleton**. Это означает, что один и тот же экземпляр этих классов будет использоваться на протяжении всей жизни приложения.

2. **Получение и использование сервисов**:
   После регистрации всех сервисов мы получаем экземпляр **`ConsoleInterface`** из контейнера зависимостей с помощью метода `GetRequiredService`. Этот экземпляр управляет взаимодействием с пользователем и выполняет основные действия в приложении.
   
3. **Преимущества использования DI**:
   - **Упрощает тестирование**: С помощью DI легко подменять реальные реализации объектов на моки или фейковые объекты для юнит-тестирования.
   - **Гибкость и расширяемость**: Если потребуется изменить реализацию проверки здоровья животных (например, подключить новый сервис), достаточно изменить только конфигурацию DI-контейнера, не затрагивая остальные части программы.


